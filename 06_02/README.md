# 6/2
## ペアプロ席替え
- レポートの評価が高い人と低い人
- 後は県内、県外とかでランダム

## 今週のお告げ
- 「ペアプログラミングは意思疎通しながら作業する」
- 意味がわからないことは聞こう
- 例えばdriver は黙々とただやるのではなく、**何をやろうとしてるのかを話しながら**作業する
- observer は気づいたことがあれば指摘しよう, わからないことがあれば質問しよう
- 2人で悩んでも答えが出ない質問なら他の人(先輩、TA、教員)に質問しよう

## レポート関連
- Google Classroom はやっぱりなし
- レポート課題2の提出先もGoogle ドキュメントの「report2」に変更
- レポート1 の採点結果とコメントを Google ドキュメントにアップロードしてる

## 関数や仕様はどう決定したら良いか?
- 代表的な原則
    - KISS 原則
        - Keep it simple, stupid!
        - 小さくつくり、組み合わせる
            - 一つの関数は一つの作業をこなす
                - 1関数=数10行程度
                - 50行ぐらいになったら分割できな以下を考えてみよう
                - 長過ぎるブロックは読みづらく、バグに気づきにくく、再利用しにくい
        - 各部品(関数をテストする)
            - 検証・再現性を意識する
            - そのテストの際手作業でやると10万行レベルのコードだと大変
                - そのためにテストを自動化する(doctest)

    - DRY 原則
        - Don't repeat yourself
        - 繰り返しを避ける
        - 同じ構造のコードを繰り返し書かない(forやwhile 等でループできないかを考える)

## doctest 補足
- ユニットテストの書き方
    - docstring 形式のドキュメント中に、インタプリタの出力を含めた実行例と結果例を記入
    - インデントを揃えることとスペースの有無に注意
- テストしたい関数の例

``` python
def add(x,y):
    result = x + y
    return result
```

- テストを含めた例

``` python
def add(x,y):
    """
    >>> add(1,2)
    3
    """
    result = x + y
    return result

if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

## 何のためにユニットテストを書くのか?
- 関数が想定通りに動くことを検証しやすくする
    - KISS 原則でも書いた通り、膨大なコードを毎回て動作確認するのは辛い
    - 「想定通り」の質が確認者に強く依存してしまう
    - 「動作例」を記述することで、想定している使い方を示すことにも成る
- リファクタリング
    - 機能を保ったままコードを修正
    - 自分のコードを別の人がリファクタリングする場合もある
    - その際、テストがあったら、そのコードが何を処理するのかがわかるため、修正しやすくなる
- テスト駆動開発
    - テストを先に書くことで、その関数をどう動作させたいかを明確にする
    - 書いたテストが通るようにコードを書く

## 4.3 Recursion(再帰) p.45, factorial funciton(階乗関数)

``` python
# コード例1
# これまでの反復を利用
def factl(n):
    """interative function
    >>> factl(1)
    1
    >>> factl(3)
    6
    """
    result=1
    while n>1:
        result = result * n
        n -= 1

    return result
```


``` python
# コード例1
# 自分自身を再帰的に呼び出す
def factR(n):
    """recursive function
    >>> factR(1)
    1
    >>> factR(3)
    6
    """
    if n == 1:
        return n
    else:
        return n * factR(n-1)
```

- トップレベル(Stack no.1)
    - factR()
    - result
- factR(3)
    - 1回目の呼び出し (Stack no.2)
    - n = 3
    - factR(2) ＊factR(3)は継続中
- factR(2)
    - 2回目の呼び出し (Stack no.3)
    - n = 2
    - factR(1) ＊factR(2)は継続中
- factR(1)
    - 3回目の呼び出し (Stack no.4)
    - n = 1
    - return 1 ＊factR(1)が終了

## 普通の反復処理 vs. 再帰呼び出し
- 再帰のメリット
    - 同じ構造に対して手続きを書くならシンプルなコードになることがある
        - シンプル = 読みやすい、書きやすい、バグに気づきやすい
        - 「同じ構造」の例
            - 木構造、グラフ、、、、
- 再帰のデメリット
    - Stack Overflow
        - 関数が終るまでスタックフレームが積み重なる
        - そのためメモリに残り続ける

## 木構造
- 根(root), 枝(edge), 接点(vertex, node), 葉(leaf) で構成
- 閉路がなければ木構造
- 閉路があるとグラフ
- 何かを探したりするときによく使われるデータ構造

## Global Variables(大域変数)
- 大域変数として使いたい変数を「global」宣言してから使う
- どこからでも参照できる変数
    - 参照できるからといって使いまくると「この変数がどこからにアクセスされるのか」読み解くことが困難になる
- 原則
    - 使わないに越したことはない
    - 使うとしても最小限に抑える
    - 授業としては「原則禁止」
    - どうしても使いたいなら、その理由を解説した上で使用すること(基本的に使わなくても書ける)

## まとめ
- KISS原則とDRY原則
    - 1関数をシンプルにする
    - 機能をテストする
    - 繰り返し同じコードを書かない
- ユニットテスト
    - 動作検証の自動化, リファクタリング
- 再帰
    - 関数自身を繰り返し呼ぶことで処理しやすいケースがある
- 木構造,グラフ構造
    - 「基本構造」はツール
    - その構造に落としこむ形でモデル化できる想定漏れを防ぎやすい(コードにしやすい)
- 大域変数
    - 原則禁止
